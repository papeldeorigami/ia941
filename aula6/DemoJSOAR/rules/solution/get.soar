sp {propose*get
   (state <s> ^name solution
              ^desired <desired>
              ^knapsack <knapsack>
              ^memory <memory>
              ^io.input-link.CREATURE <creature>)
   (<creature> ^SENSOR.VISUAL.ENTITY <entity>)
   # find a jewel
   (<entity> ^NAME <entityName>
             ^TYPE JEWEL
             ^COLOR <color>
             # get only if distance is less than 30
             ^DISTANCE { <DISTANCE> < 30 })
   # get only if already seen
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity> ^NAME <entityName>
                  -^collected) # check if not collected before
   # filter colors only that are missing in some leaflet
   (<desired> ^<color> <desiredQuantity>)
   (<knapsack> ^<color> { <quantity> < <desiredQuantity> })
   # if not getting something already
  -(<out> ^GET)
-->
   (<s> ^operator <o> + =)
   (<o> ^name get
        ^parameter.NAME <entityName>)
   (write (crlf) | propose get: name = | <entityName> | distance = | <DISTANCE> ||)
#   (write (crlf) | desired=| <desired> | knapsack=| <knapsack> | memory=| <memory> ||)
#   (write (crlf) | creature=| <creature> | entity=| <entity> | desiredQuantity=| <desiredQuantity> ||)
#   (write (crlf) | color=| <color> | memoryEntity=| <memoryEntity> | entityName=| <entityName> ||)
#   (write (crlf) | quantity=| <quantity> ||)
}

sp {solution*apply*get
   (state <s> ^operator <o>
              ^knapsack <knapsack>
              ^memory <memory>
              ^desired <desired>
              ^io.output-link <out>
              ^io.input-link.CREATURE <creature>)
   # read the jewel name from parameters
   (<o> ^name get
        ^parameter <p>)
   (<p> ^NAME <entityName>)
   # lookup the entity in the visual sensor
   (<creature> ^SENSOR.VISUAL <visual>)
   (<visual> ^ENTITY <visualEntity>)
   (<visualEntity> ^NAME <entityName>)
   # lookup the entity in the memory
   (<memory> ^ENTITY <memoryEntity>)
   (<memoryEntity>
             ^NAME <entityName>
             ^COLOR <color>
            -^collected)
   # lookup the color status in the knapsack and in the desired state
   (<knapsack> ^<color> <quantity>
               ^Red <kred>
               ^Green <kgreen>
               ^Blue <kblue>
               ^Yellow <kyellow>
               ^Magenta <kmagenta>
               ^White <kwhite>)
   (<desired> ^<color> <dquantity>
              ^Red <dred>
              ^Green <dgreen>
              ^Blue <dblue>
              ^Yellow <dyellow>
              ^Magenta <dmagenta>
              ^White <dwhite>)
   # if not getting something already
  -(<out> ^GET)
-->
   # remove element from the input (temporary)
   (<visual> ^ENTITY <visualEntity> -)
   # mark element as collected in memory
   (<memoryEntity> ^collected true)
   # increment the number of jewels of the entity's color in the knapsack
   (<knapsack> ^<color> <quantity> -
               ^<color> (+ <quantity> 1))
   # prepare the output action
   #(<actions> ^GET <command>)
   #(<command> ^Name <entityName>)
   (<out> ^GET.Name <entityName>)
   (write (crlf) | get: name = | <entityName> | Knapsack was: |)
   (write (crlf) | Red=| <kred> |/| <dred> ||)
   (write (crlf) | Green=| <kgreen> |/| <dgreen> ||)
   (write (crlf) | Blue=| <kblue> |/| <dblue> ||)
   (write (crlf) | Yellow=| <kyellow> |/| <dyellow> ||)
   (write (crlf) | Magenta=| <kmagenta> |/| <dmagenta> ||)
   (write (crlf) | White=| <kwhite> |/| <dwhite> ||)
   (write (crlf) | ---> | <color> | is now | (+ <quantity> 1) |/| <dquantity> ||)
}

#sp {solution*apply*get*test
#   (state <s> ^operator <o>)
#   # read the jewel name from parameters
#   (<o> ^name get
#        ^parameter <p>)
#   (<p> ^NAME <entityName>)   
#-->
#   (write (crlf) | ======= apply get entityName=| <entityName> ||)
#   (write (crlf) (cmd print --depth 1 <s>))
#}
#
